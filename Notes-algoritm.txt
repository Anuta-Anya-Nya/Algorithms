Алгоритм - любая программа, последовательность действий для достижения конечной цели

Критерии сложности:
    скорость работы
    обьем потребляемой памяти

линейная зависимость
квадратичная зависимость
экспоненциальная зависимость

есть О по производитетьности и О по памяти 


О большое - относительно, насколько количество операций возрастает от входящих данных
https://t.me/iksergeyru/121 шпаргалка
https://leetcode.com/problemset/all/ алгоритмические задачи

Правила обьединения сложности (цифровые значения откидываются, так как ни на что не влияют и кривизна графика не меняется)
вызов нескольких методов на каждом шаге: О(2n)==O(n)
обход половины размерности массива: O(n/2) == O(n)
Вызов нескоольких методов вне цикла: O(2+n)==O(n)

Правила оьединения сложности
method1 имеет сложность O(n^3)
method2 имеет сложность O(n^2)

если внутри метода1 вызывается метод2, сложности перемножаются O(n^3) * O(n^2) == O(n^5)
если методы вызываются последовательно, то сложности складываются, т.е. берется маскимальная O(n^3) + O(n^2) == O(n^3)

Какие бывают сложности алгоритмов:
● O(1) - константная. Не зависит от объема данных. 
Например - поиск по хэш-таблице
● O(log n) - логарифмическая. Увеличение размера 
почти не сказывается на количестве итераций. 
Например - бинарный поиск, поиск по 
сбалансированному дереву
● O(n) - линейная. Увеличение сложности эквивалентно 
увеличению размера. Например - поиск по 
неотсортированному массиву
● O(n * log n) - увеличение размера заметно 
сказывается на сложности. Например - быстрая 
сортировка
● O(n^2) - квадратичная. Увеличение размера очень 
сильно сказывается на сложности. Например -
пузырьковая сортировка
● O(2^n) - экспоненциальная. С увеличением размера 
на 1, сложность возрастает вдвое

массив - контейнер, хранит данные по индексу. знает по какому конкретному индексу что находится
простые алгоритмы сортировки:
имеют сложность поиска -O(n^2)-
пузырьковая  сравниваются попарные элементы и больший двигается вправо
сортировка выбором - берет первый элемент, сравнивает его с другими, находит минимальный и меняет местами
сортировка вставками - берем первый элемент и сравниваем во следующими, при нахождении минимального меняем местами, продолжаем перебор

Алгоритмы поиска
простой перебор O(n)
бинарный поиск O(log n)

быстрая сортировка O(n Log n) (максимальная сложность n^2) (минимальная сложность О(n) если все элементы на своих местах) берется пивот (центральный элемент). и сравниваются элементы слева и справа, заменяются (меньше пивота - идут налево, больше - направо), затем бьются на части от пивота, рекурсивно повторяется
пирамидальная сортировка (бинарной кучей) -O(n Log n)- просеивание - больший элемент становится родителем. нисходящая куча, восходящая куча 

СВЯЗНЫЕ СПИСКИ
базовая структура данных, состоящая из узлов, который состоит из ссылок на 1(следующий - односвязнй) или 2 узла(предыдущий и следующий двусвязный).

Операции со связным списке:
поиск - сложность перебора O(n); невозможно использовать бинарный поиск из-за отсутствия работы с индексами
вставка в связный список в начало и конец O(1), но поиск места вставки может занимать О(n)
    в конец или в начало выгоднее в связном списке, чем в массиве, потому что не надо сдвигать все элементы, а просто заменить ссылки. 
удаление  O(1)- аналогично вставке
разворот 



преимущества связного списка:
масслвые вставки и удадение в конец-начало списка (если чазе писать, чем читать)
массовые вставки и удажения в середину, если поис выполняется единожды
динамическая расширяемость

СТЕК и ОЧЕРЕДЬ 
удобнее на связанном списке
стек - LIFO последнийдобавленный, первый извлеченный (стопка бумаги) - например журналы операций. односвязный список
очередь FIFO первый зашел первый вышедл - очередь в магазине, двусвязный списоок

Дерево - структура данных, в виде связанных узловю
корень - не имеет родителей
листья - не имеют детей
узлы дерева - все остальное

Обход в глубину - рекурсивный обход узлов дерева
Обход в ширину - проверка каждого уровня по горизонтали, более ресурснозатратен чем в глубину

бинарное дерево - частный случай, количество детей у каждого родителя не юолее 2, левый ребенок всегда меньше чем родитель, правый - больше
сбалансированное бинарное дерево - разница глубины каждого поддерева различается максимум на 1

если добавлять-удалять то хэшТаблица
если поиск - красно-черное дерево 

